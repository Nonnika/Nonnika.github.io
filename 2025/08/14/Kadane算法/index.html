<!DOCTYPE html>
<html>
    <head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    name="viewport" />
  <meta name="robots" content="index, follow">
  <!-- title -->
  
            
                    <title>
                      Kadane算法 - Nonnika&#39;s Blog
                    </title>
                    
                          

                            <!-- open graph -->
                            <meta name="description" content="Kadane算法——最大子数组和问题 问题定义 给定一个整数数组，找出其中和最大的连续子数组，并返回这个最大和。 子数组：数组中连续的元素序列。例如数组 [1,2,3,4] 的子数组有 [1]、[1,2]、[2,3]、[1,2,3] 等。 Kadane算法的核心思想 Kadane算法基于动态规划的思想，通过一次遍历就能找到最大子数组和。 核心状态转移方程： dp[i] &#x3D; max(nums[i]">
<meta property="og:type" content="article">
<meta property="og:title" content="Kadane算法">
<meta property="og:url" content="https://blog.liewyoung.top/2025/08/14/Kadane%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Nonnika&#39;s Blog">
<meta property="og:description" content="Kadane算法——最大子数组和问题 问题定义 给定一个整数数组，找出其中和最大的连续子数组，并返回这个最大和。 子数组：数组中连续的元素序列。例如数组 [1,2,3,4] 的子数组有 [1]、[1,2]、[2,3]、[1,2,3] 等。 Kadane算法的核心思想 Kadane算法基于动态规划的思想，通过一次遍历就能找到最大子数组和。 核心状态转移方程： dp[i] &#x3D; max(nums[i]">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-14T10:37:00.000Z">
<meta property="article:modified_time" content="2026-02-05T07:37:18.354Z">
<meta property="article:author" content="Nonnika">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
                              <!-- canonical -->
                              
                                    <link rel="canonical"
                                      href="https://blog.liewyoung.top/2025/08/14/Kadane算法/">
                                    
                                      <!-- Favicon (已移除) -->
                                      <!-- CSS -->
                                      
<link rel="stylesheet" href="/css/reset.css">

                                        
<link rel="stylesheet" href="/css/style.css">

                                          
<link rel="stylesheet" href="/css/markdown.css">

                                            
<link rel="stylesheet" href="/css/fonts.css">

                                              
<link rel="stylesheet" href="/css/github.css">

<meta name="generator" content="Hexo 7.3.0"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Nonnika&#39;s Blog</a>
    <!-- <div class="logo"><a href="/" title="Len"><img src="/img/logo.svg" alt="Len" aria-label="logo" height="20"></a></div> -->
        <ul class="nav">
            
            <li><a href="/">Home</a></li>
            
            <li><a href="/about">About</a></li>
            
            <li><a href="/archives">Archives</a></li>
            
        </ul>


    </a>
</div>

                
                <div class="post-main">
    
        <div class="post-main-title">
            Kadane算法
        </div>
        <div class="post-meta">
            2025-08-14 ｜ 
            
                <a href="/categories/ACM/"># ACM</a>
            
        </div>
        <!-- 圆角分类 -->
        <!-- <div class="tags"> -->
            <!--  -->
                <!-- <a href="/categories/ACM/">ACM</a> -->
            <!--  -->
        <!-- </div> -->
        <div class="post-md">
            <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="kadane算法最大子数组和问题"><a class="markdownIt-Anchor" href="#kadane算法最大子数组和问题"></a> Kadane算法——最大子数组和问题</h2>
<p>问题定义<br />
给定一个整数数组，找出其中和最大的连续子数组，并返回这个最大和。<br />
子数组：数组中连续的元素序列。例如数组 [1,2,3,4] 的子数组有 [1]、[1,2]、[2,3]、[1,2,3] 等。<br />
Kadane算法的核心思想<br />
Kadane算法基于动态规划的思想，通过一次遍历就能找到最大子数组和。<br />
核心状态转移方程：<br />
dp[i] = max(nums[i], dp[i-1] + nums[i])</p>
<p>其中 dp[i] 表示以第i个元素结尾的最大子数组和。</p>
<h3 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤：</h3>
<ol>
<li>维护两个变量：current_max（当前最大值）和 global_max（全局最大值）</li>
<li>从第二个元素开始遍历数组</li>
<li>对于每个元素，选择较大值：要么单独成为新的子数组开始，要么加入前面的子数组</li>
<li>更新全局最大值</li>
</ol>
<h3 id="算法示例"><a class="markdownIt-Anchor" href="#算法示例"></a> 算法示例</h3>
<p>以数组 [5, -3, 2, -1, 4] 为例：<br />
初始：current_max = 5, global_max = 5</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i=<span class="hljs-number">1</span>, nums[<span class="hljs-number">1</span>]=<span class="hljs-number">-3</span>:<br>  current_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">-3</span>, <span class="hljs-number">5</span>+(<span class="hljs-number">-3</span>)) = <span class="hljs-built_in">max</span>(<span class="hljs-number">-3</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">2</span><br>  global_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>) = <span class="hljs-number">5</span><br><br>i=<span class="hljs-number">2</span>, nums[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>:<br>  current_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span><span class="hljs-number">+2</span>) = <span class="hljs-number">4</span><br>  global_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>) = <span class="hljs-number">5</span><br><br>i=<span class="hljs-number">3</span>, nums[<span class="hljs-number">3</span>]=<span class="hljs-number">-1</span>:<br>  current_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">4</span>+(<span class="hljs-number">-1</span>)) = <span class="hljs-number">3</span><br>  global_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>) = <span class="hljs-number">5</span><br><br>i=<span class="hljs-number">4</span>, nums[<span class="hljs-number">4</span>]=<span class="hljs-number">4</span>:<br>  current_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span><span class="hljs-number">+4</span>) = <span class="hljs-number">7</span><br>  global_max = <span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>) = <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
<p>最终答案：7，对应子数组 [2, -1, 4]</p>
<h3 id="为什么这样做是对的"><a class="markdownIt-Anchor" href="#为什么这样做是对的"></a> 为什么这样做是对的？</h3>
<p>当 current_max + nums[i] &lt; nums[i] 时，说明前面的子数组对当前元素产生了&quot;负贡献&quot;，此时应该抛弃前面的结果，从当前元素重新开始。这样保证了每一步都选择局部最优解，最终得到全局最优解。<br />
完整代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> max_sum;<br>    <span class="hljs-type">int</span> start;<br>    <span class="hljs-type">int</span> end;<br>&#125;;<br><br><span class="hljs-function">Result <span class="hljs-title">kadane</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> current_max = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> global_max = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>, temp_start = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; current_max + nums[i]) &#123;<br>            current_max = nums[i];<br>            temp_start = i;  <span class="hljs-comment">// 新的候选起点</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            current_max += nums[i];<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (current_max &gt; global_max) &#123;<br>            global_max = current_max;<br>            start = temp_start;<br>            end = i;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> &#123;global_max, start, end&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <br>    Result result = <span class="hljs-built_in">kadane</span>(nums);<br>    cout &lt;&lt; <span class="hljs-string">&quot;最大子数组和: &quot;</span> &lt;&lt; result.max_sum &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;子数组范围: [&quot;</span> &lt;&lt; result.start &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; result.end &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)，只需要一次遍历</li>
<li>空间复杂度：O(1)，只使用了常数个额外变量</li>
</ul>
<p>特殊情况处理</p>
<ol>
<li>全为负数：返回最大的那个负数</li>
<li>空数组：根据题目要求返回0或报错</li>
<li>数据范围大：使用 long long 防止溢出</li>
</ol>
<h2 id="推荐练习题"><a class="markdownIt-Anchor" href="#推荐练习题"></a> 推荐练习题</h2>
<ul>
<li>LeetCode 53: Maximum Subarray</li>
<li>LeetCode 918: Maximum Sum Circular Subarray</li>
<li>杭电OJ 1003: Max Sum</li>
</ul>
<h2 id="算法扩展"><a class="markdownIt-Anchor" href="#算法扩展"></a> 算法扩展</h2>
<ul>
<li>二维数组的最大子矩阵和</li>
<li>环形数组的最大子数组和</li>
<li>找出所有最大和的子数组</li>
</ul>
<p>Kadane算法是动态规划在数组问题中的经典应用，掌握其思想对解决类似问题很有帮助。</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script>
        </div>
    
<!-- tags -->

    <div class="post-meta">
        标签：
        
            <a href="/tags/%E7%AE%97%E6%B3%95/"> / 算法</a>
        
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"> / 动态规划</a>
        
    </div>

</div>
                <div class="footer">
    <span>Copyright © <script>document.write(new Date().getFullYear())</script> Nonnika&#39;s Blog</span>
    <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> with <a target="_blank" rel="noopener" href="https:///imzl.com/zenmind">ZenMind</a></span>
</div>

<link rel="stylesheet" href="/css/github.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>

<script>
    // Hexo 已在服务端完成代码高亮，客户端不需要再次处理
    // hljs.initHighlightingOnLoad();
    // hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>