[{"title":"AI让我们变弱了吗","url":"/2025/10/23/AI%E8%AE%A9%E6%88%91%E4%BB%AC%E5%8F%98%E5%BC%B1%E4%BA%86%E5%90%97/","content":"辩题分析：AI时代，使人变得更强还是更弱了？\n​首先分析辩题，“AI”和“人类”是相当经典的科技进步与人类机能的关系。我们要从“强”和“弱”这两个方面来看，在矛盾中寻找统一的关系，最终得出观点。\n​先分析辩题涉及的范围“AI”。那我们要如何理解AI呢？首先，我们要明确一个问题，AI也就是artificial intelligence（人工智能）。人工智能并不局限于在课堂中同学一直分析的LLM（大型语言模型），AI在传统的交通管理、大数据分析，乃至科研医疗等领域均有广泛的应用。所谓“AI时代”，实际上是指人类广泛借助AI技术来减轻人力劳动的时代。\n​其次，什么是“强”？什么是“弱”？我们在面对这个问题时，需要思考一个问题，那就是“评价体系”。不同的时代，应有不同的评价体系。也就是说，如果我们以过去农耕文明的“机能”角度来看人类是否变得更强，那无疑是否定的。\n​但是，事物是发展的，所以评价体系也应当改进。如果我们把评价体系由个体“机能”变成人类整体进一步的“价值创造”，比如智慧医疗，过去在医院天天上下跑拿片子，现在借助AI我们不仅可以网上查片，还可以个性化医疗，那无疑是进步的。所以，在分析“强”和“弱”的时候，要明确注意分析价值体系的变化。\n所以是强是弱，我们应该具有发展的眼光明白强弱的本质，好比学习如果你以学校评价体系来看我们自己，我们无疑是成功的，但是如果我们以终身学习的角度去看，大部分人其实是极其失败的。即使没有AI对于我们来说，我们本身就是传统意义的弱。\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["思考"]},{"title":"Http方法","url":"/2026/02/08/Http%E6%96%B9%E6%B3%95/","content":"Http 方法\nHTTP 定义了一组 方法 。每次我们发起 HTTP 请求时，都必须选择其中一个。最常见的方法包括：\nGET\nPOST\nPUT\nDELETE\nGET 方法\nGET  方法用于获取服务器资源，它获取资源副本或者资源的表示形式。 其被认为是一种安全的方法，因为其不改变服务器的状态。\n用 Go 发起一个 GET  请求\nresp, err := http.Get(&quot;&lt;URL&gt;&quot;)\nPOST  方法\nPSOT 方法用于将请求发送到服务器创建新资源\n用 Go 发起一个 POST 请求\nresp, err := http.Post(url, &quot;application/json&quot;, bytes.NewBuffer(jsonData))\nPUT 方法\nPUT 方法常用于更新数据，为什么说常用于更新数据？因为比如我们创建一个用户 ID：001,我们可以使用 PUT 方法告诉服务“Hi Bro，把这个加上去”。你可以会疑问**为什么不用 POST **？说的对，确实可以使用 POST 但是我们一般不这样因为 PUT 的理念就是 “ 保持资源一致性”，服务器会遵守 PUT 携带的数据并对于重复 PUT 仅创建一次资源且返回 200 状态码，但对于 POST 很可能不是这样，使用 POST 会带来两种可能：\n\n创建多个重复资源\n返回 40X 状态码\n\nDELETE 方法\nDELETE 方法的作用正如你所预期：删除指定的资源。\n最后一个问题： 为什么要用这些方法？\n我们对于服务器的操作大到 LLM 如：豆包、千问、DeepSeek ,小到学校的学生信息录入。都不过是 CRUD （Create Remove Update Delete）的变体 。我们规范这些操作也方便与后端程序程序员对应。\n附录：\nSTATUS CODE：\n200 OK\n201 Created\n204 No Content\n301 Moved Permanently\n304 Not Modified\n400 Bad Request\n401 Unauthorized\n403 Forbidden\n404 Not Found\n409 Conflict\n500 Internal Server Error\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["Go语言学习"],"tags":["Go"]},{"title":"Kadane算法","url":"/2025/08/14/Kadane%E7%AE%97%E6%B3%95/","content":"Kadane算法——最大子数组和问题\n问题定义\n给定一个整数数组，找出其中和最大的连续子数组，并返回这个最大和。\n子数组：数组中连续的元素序列。例如数组 [1,2,3,4] 的子数组有 [1]、[1,2]、[2,3]、[1,2,3] 等。\nKadane算法的核心思想\nKadane算法基于动态规划的思想，通过一次遍历就能找到最大子数组和。\n核心状态转移方程：\ndp[i] = max(nums[i], dp[i-1] + nums[i])\n其中 dp[i] 表示以第i个元素结尾的最大子数组和。\n算法步骤：\n\n维护两个变量：current_max（当前最大值）和 global_max（全局最大值）\n从第二个元素开始遍历数组\n对于每个元素，选择较大值：要么单独成为新的子数组开始，要么加入前面的子数组\n更新全局最大值\n\n算法示例\n以数组 [5, -3, 2, -1, 4] 为例：\n初始：current_max = 5, global_max = 5\ni=1, nums[1]=-3:  current_max = max(-3, 5+(-3)) = max(-3, 2) = 2  global_max = max(5, 2) = 5i=2, nums[2]=2:  current_max = max(2, 2+2) = 4  global_max = max(5, 4) = 5i=3, nums[3]=-1:  current_max = max(-1, 4+(-1)) = 3  global_max = max(5, 3) = 5i=4, nums[4]=4:  current_max = max(4, 3+4) = 7  global_max = max(5, 7) = 7\n最终答案：7，对应子数组 [2, -1, 4]\n为什么这样做是对的？\n当 current_max + nums[i] &lt; nums[i] 时，说明前面的子数组对当前元素产生了&quot;负贡献&quot;，此时应该抛弃前面的结果，从当前元素重新开始。这样保证了每一步都选择局部最优解，最终得到全局最优解。\n完整代码实现\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Result &#123;    long long max_sum;    int start;    int end;&#125;;Result kadane(const vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if (n == 0) return &#123;0, -1, -1&#125;;        long long current_max = nums[0];    long long global_max = nums[0];    int start = 0, end = 0, temp_start = 0;        for (int i = 1; i &lt; n; i++) &#123;        if (nums[i] &gt; current_max + nums[i]) &#123;            current_max = nums[i];            temp_start = i;  // 新的候选起点        &#125; else &#123;            current_max += nums[i];        &#125;                if (current_max &gt; global_max) &#123;            global_max = current_max;            start = temp_start;            end = i;        &#125;    &#125;        return &#123;global_max, start, end&#125;;&#125;int main() &#123;    int n;    cin &gt;&gt; n;        vector&lt;int&gt; nums(n);    for (int i = 0; i &lt; n; i++) &#123;        cin &gt;&gt; nums[i];    &#125;        Result result = kadane(nums);    cout &lt;&lt; &quot;最大子数组和: &quot; &lt;&lt; result.max_sum &lt;&lt; endl;    cout &lt;&lt; &quot;子数组范围: [&quot; &lt;&lt; result.start &lt;&lt; &quot;, &quot; &lt;&lt; result.end &lt;&lt; &quot;]&quot; &lt;&lt; endl;        return 0;&#125;\n复杂度分析\n\n时间复杂度：O(n)，只需要一次遍历\n空间复杂度：O(1)，只使用了常数个额外变量\n\n特殊情况处理\n\n全为负数：返回最大的那个负数\n空数组：根据题目要求返回0或报错\n数据范围大：使用 long long 防止溢出\n\n推荐练习题\n\nLeetCode 53: Maximum Subarray\nLeetCode 918: Maximum Sum Circular Subarray\n杭电OJ 1003: Max Sum\n\n算法扩展\n\n二维数组的最大子矩阵和\n环形数组的最大子数组和\n找出所有最大和的子数组\n\nKadane算法是动态规划在数组问题中的经典应用，掌握其思想对解决类似问题很有帮助。\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["ACM"],"tags":["算法","动态规划"]},{"title":"JetpackCompose声明式框架","url":"/2025/09/01/JetpackCompose%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%A1%86%E6%9E%B6/","content":"声明式框架：从底层逻辑到实践\n\n本文使用AIGC生成\n\n一、什么是声明式框架？\n核心定义：声明式框架是一种编程范式，开发者只需描述&quot;UI应该是什么样子&quot;，而不必关心&quot;如何实现这个样子&quot;。\n// 声明式伪代码示例UI &#123;   Text(&quot;Hello World&quot;)   Button(&quot;Click Me&quot;) &#125;\n本质区别：\n\n命令式：一步一步告诉计算机&quot;如何做&quot;\n声明式：直接告诉计算机&quot;要什么结果&quot;\n\n二、为什么声明式比命令式更好？\n1. 消除样板代码\n命令式UI需要大量代码来处理状态同步和UI更新，声明式框架让这些变得多余。\n2. 减少状态错误\n状态管理集中化，避免了&quot;状态不同步&quot;导致的各种奇奇怪怪的UI问题。\n3. 提高代码可读性\n代码直接反映UI结构，就像在写HTML一样直观。\n4. 优化性能\n声明式框架内部通常有智能的差异对比算法，只更新真正需要变化的部分。\n三、声明式框架的技术基础\n1. 数据绑定机制\n状态变化自动反映到UI，UI事件也能自动更新状态。\n2. 组件化设计\nUI被拆分为可复用的组件，每个组件只关注自己的状态和表现。\n3. 差异对比算法\n(Virtual DOM/Compose中的Slot Table)，高效计算最小更新集。\n4. 单向数据流\n数据流向清晰，便于追踪和调试问题。\n四、Jetpack Compose：Android的声明式革命\n1. Compose的核心理念\n\n组合优于继承\n单一可信来源\n状态驱动UI\n副作用管理\n\n2. Compose与传统View系统的区别\n\n告别XML布局文件\n告别findViewById和各种监听器\n告别Fragment的复杂性\n告别Adapter和ViewHolder的样板代码\n\n3. Compose的技术优势\n\nKotlin语言的完全集成\n函数式编程模型\n高效的重组机制\n强大的动画支持\n\n五、从命令式到声明式：思维转变\n1. 忘记&quot;怎么更新UI&quot;\n只关注&quot;UI应该长什么样&quot;\n2. 拥抱不可变性\n优先使用不可变数据结构，让状态变化可预测\n3. 学会状态提升\n将状态提升到共同的父组件中管理\n4. 理解重组概念\nCompose的重组是智能的，但需要遵循其规则\n\nLinus 式思考总结\n好品味：声明式框架体现了&quot;好品味&quot;的设计哲学——通过重新思考问题本质，消除了大量特殊情况和条件判断。\n实用主义：虽然理论上增加了一层抽象，但实际上极大简化了开发流程，解决了真实存在的UI同步问题。\n简洁执念：声明式代码通常比命令式代码更短、更清晰，用更少的概念解决了更复杂的问题。\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["Android"],"tags":["JetpackCompose"]},{"title":"SDL入门","url":"/2025/08/10/SDL%E5%85%A5%E9%97%A8/","content":"我的SDL3之旅（面向C语言初学者）：DAY1认识基本结构和创建窗口\n\n在上一篇文章中我们已经配置好了SDL3环境现在我们可以来写SDL3的代码了。\n如果没有配置请转到环境配置\n\n开发环境：Virtual Studio 2022\n基本框架\n值得一提的是SDL3与SDL2不同，其舍弃了传统的main函数的入口模式，转而使用四个基本函数来处理程序的生命周期。下面我们来认识一下。\n初始化函数\nSDL_AppResult SDL_AppInit(void** appstate, int argc, char* argv[])\n这个函数会在程序开始执行时运行一次，如果学过OOP的编程语言可以把这个类比成类的构造函数其只会执行一次。\n参数解释\nvoid** appstate首先是一个二级指针，其指向的指针是一个结构体指针，其的作用主要是管理程序的相关状态。里面可以管理如**窗口（window）、渲染器（renderer）**一类的状态信息。\n int argc, char* argv[]这些是C/C++的传统命令行参数。\n事件响应函数\nSDL_AppResult SDL_AppEvent(void* appstate,SDL_Event* event)\n这个函数会在有事件（如鼠标点击、键盘输入、QUIT退出）时调用。\n参数解释\nvoid* appstate是一个指针传入APP的状态管理参数\nSDL_Event* event 负责传入APP当前响应的事件\n帧渲染函数（主函数）\nSDL_AppResult SDL_AppIterate(void* appstate)\n这个函数会在每一帧运行一次，有点类似传统的while死循环方法。\n里面会处理你程序运行时的各种事件，当然也包括图形渲染。\n后处理函数\nvoid SDL_AppQuit(void* appstate,SDL_AppResult result)\n这个函数会在程序生命结束时调用，SDL会帮我们清理渲染和屏幕。同样的学过OOP编程语言的可以拿析构函数类比\n参数解释\nSDL_AppResult result这个会传入程序的运行结构，如SUCCESS或者FALIURE\n创建窗口\n前置条件\n\n安装了SDL3环境\n具备基本的C/C++知识\n\n知识补充\n\n屏幕坐标系\n\n\n屏幕坐标系是建立在屏幕上的二维坐标系，以像素为单位。屏幕的左上角为原点，水平方向为X轴，向右为正；垂直方向为Y轴，向下为正。\n\n\n计算机是如何渲染视频的\n\n\n我们看到的视频实际上有由一系列连续的图像形成的，我们把每一张图像叫做帧（fame）\n\n书写代码\n首先定义宏来启用新式写法\n#define SDL_MAIN_USE_CALLBACKS 1\n现在引入头文件\n#include&lt;SDL3/SDL.h&gt;#include&lt;SDL3/SDL_main.h&gt;\n创建窗口也遵循传统的 '声明-初始-使用' 的基本形式。\n现在定义两个全局变量\nstatic SDL_Window* window = NULL;static SDL_Renderer* renderer = NULL;\n现在我们可以开始写第一个函数了\nSDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[]) &#123;&#125;\n首先我们需要调用\nSDL_SetAppMetadata( )函数来初始化程序的名称等。\n\nSDL_SetAppMetadata拥有三个参数（程序名称，版本信息，标识符）用于设置APP的元数据\n\n这里使用官方的Demo名称\nSDL_SetAppMetadata(&quot;Example Renderer Clear&quot;, &quot;1.0&quot;, &quot;com.example.renderer-clear&quot;);\n下面来初始化窗口和渲染器\nif (!SDL_Init(SDL_INIT_VIDEO)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t initialize SDL :%s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;/*此处Windowsflag参数被设置为0 表示默认设置*/\tif (!SDL_CreateWindowAndRenderer(&quot;examples/renderer/clear&quot;, 640, 480, 0,&amp;window ,&amp;renderer)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t create window/renderer %s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;\n\n这里使用了SDL_Init()和SDL_CreateWindowAndRenderer()其实我们可以顾名思义一个是用来初始化权限的一个是用来创建窗口和渲染器的。\nSDL_GetError()会返回字符串内容是错误信息。\nSDL_Log()是SDL内置的日志打印函数。\n\n这里需要提一下SDL_Init()函数是使用|与运算符来申请多个权限的比如\nSDL_Init(SDL_INIT_VIDEO|SDL_INIT_AUDIO);\n下面是完整代码\n/*这个函数会在开始时执行一次*/SDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[]) &#123;\t\t/*设置元数据*/\tSDL_SetAppMetadata(&quot;Example Renderer Clear&quot;, &quot;1.0&quot;, &quot;com.example.renderer-clear&quot;);\tif (!SDL_Init(SDL_INIT_VIDEO)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t initialize SDL :%s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;/*此处Windowsflag参数被设置为0 表示默认设置*/\tif (!SDL_CreateWindowAndRenderer(&quot;examples/renderer/clear&quot;, 640, 480, 0,&amp;window ,&amp;renderer)) &#123;\t\tSDL_Log(&quot;Couldn&#x27;t create window/renderer %s&quot;, SDL_GetError());\t\treturn SDL_APP_FAILURE;\t&#125;\treturn SDL_APP_CONTINUE;&#125;\n下面的函数很简单先略过\n/*这个函数会在有事件（如：鼠标、键盘输入）时调用*/SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event) &#123;\tif (event-&gt;type == SDL_EVENT_QUIT) &#123;\t\treturn SDL_APP_SUCCESS; /*向操作系统传递程序成功执行*/\t&#125;\treturn SDL_APP_CONTINUE;&#125;\n下面开始主函数SDL_AppResult SDL_AppIterate(void* appstate)\n/*下面设置渲染器*/SDL_AppResult SDL_AppIterate(void* appstate)&#123;\tSDL_SetRenderDrawColorFloat(renderer, 255, 255, 255, SDL_ALPHA_OPAQUE_FLOAT);\t/*下面clear上一次渲染的内容*/\tSDL_RenderClear(renderer);\t/*现在把新的渲染器放到屏幕上*/\tSDL_RenderPresent(renderer);\treturn SDL_APP_CONTINUE;&#125;\n现在解释一下SDL_SetRenderDrawColorFloat()函数其接受渲染器和颜色（RGB）来设置渲染器颜色。SDL_ALPHA_OPAQUE_FLOAT是一个官方宏，表示不透明且是浮点型的参数。\n最后结尾\nvoid SDL_AppQuit(void* appstate,SDL_AppResult result) &#123;\t/*pass*/&#125;\n写在后面\nQ&amp;A\n为什么第一个SDL_AppResult SDL_AppInit(void** appstate, int argc, char* agrv[])的appstate参数是二级指针？\n\n因为这个函数是初始化函数，其目的是为了储存开发创建的状态对象\n其他函数只会修改这个对象的内容而不是这个对象所以是一级指针\n\n为什么没有使用appstate参数？\n\n官方说法是appstate会更方便开发者管理，尤其对于大项目，但是我使用着十分麻烦，而且我们就只是创建一个窗口，所以没有使用。\n\n你说话好啰嗦啊？\n\n你真是个小天才（开玩笑）\n其实主要面向的是刚学完C语言（不严谨就是会一点）的想图形化的同学写的。\n\n感受\n本人技术也不是很好，但还是想说两句。\n学习这个SDL3其实最好的教程已经放在官方的Demo里面了，所以剩下的就是啃接口文档了。\n如有不妥，敬请指教\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["第三方库"],"tags":["SDL3"]},{"title":"依赖注入","url":"/2025/10/23/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","content":"依赖注入\n依赖项\n很多时候，类都需要其他类的对象才能正常运行。如果某个类需要另一个类，则所需的类称为依赖项。\n依赖注入（ DI ）\n依赖项注入是指在运行时提供依赖项，而不是将其硬编码到调用类中。\n实现依赖项注入：\n\n有助于提高代码的可重用性。代码不依赖于特定对象，从而提高灵活性。\n**使重构更轻松。**代码是松散耦合的，因此重构一段代码不会影响另一段代码。\n**有助于进行测试。**可以在测试期间传入测试对象。\n\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["Android"]},{"title":"cURL基本使用","url":"/2026/02/08/cURL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"cURL 基本使用\ncurl 是目前最流行、最强大的命令行网络工具之一，全称 Client URL（客户端 URL 工具）。\n安装\n基本上不论 Windows 还是 Linux 都是预装的\n基础\ncurl https://archlinux.org  \n不加任何参数代表默认使用 GET 方法来请求数据，默认输出到 stdout 也就是标准输出。\n发送 POST 方法\ncurl -X POST &lt;URL&gt; -H &lt;content-type&gt; -d &lt;Body&gt;\n并非所有的参数s都会必须的，例如一个简单的 POST 请求只需要 -X POST -d &lt;body&gt; 就可以了。\n解析 JSON\n解析 json 并不是 curl 应该做的事情，我们可以使用另一个工具 jq 。\njq 是一个强大的 json 命令行处理工具，要使用它我们首先要安装：\n这里以 Arch Linux 为例\nsudo pacman -S jq\n之后运行\njq --version\n显示版本号就说明安装成功了。\n使用方法：\ncurl &lt;URL&gt; | jq.&lt;字段&gt;\n这里的 | 是 SHELL 中的管道。\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["Go语言学习"],"tags":["Go"]},{"title":"头脑风暴大师Prompt","url":"/2025/10/14/%E5%A4%B4%E8%84%91%E9%A3%8E%E6%9A%B4%E5%A4%A7%E5%B8%88Prompt/","content":"role: 一个思维发散但不偏离主题的良好讨论者（头脑风暴大师）special: 善于使用emojiskill: - 擅长思考对方提出的观点- 善于利用MICE方法拆解问题（MICE 方法的核心是**相互独立，完全穷尽**)- 善于提问：\t- 根据**金字塔原理**报告你的疑惑\t- 每次只提出一个疑问\t- 抓住疑问的目标是帮助对方明白自己究竟在干什么\t- 对于每次提问你可以给出几个选项或者让对方回答- 工程师思维：\t- 对于每个讨论不能局限于理论更要有应用\t- 不急于求成，不要求一次对话就解决问题\t- 善于设计原型方便快速迭代（比如：**先提出一个简略的思路或者回复，根据用户反馈不断完善**)- 费曼思维：\t- 当对方提出的是知识性问题时，你应该用最为通俗的语言教会他。\t- 生动举例，最好是**生活化**的例子 - 图表大师：\t- 你可以使用Mermaid图来解释概念并回答问题。当回应用户查询时，请遵循以下指南\t1. 分析用户的问题以确定是否适合用图表进行说明或回答。可用图表说明或回答的适当场景包括，但不限于：过程描述、层级结构、时间表、关系图等。\t2. 如果决定使用图表，选择最合适的Mermaid图表类型，如流程图、序列图、类图、状态图、实体关系图、用户旅程、甘特图、饼图、四象限图、需求图、Gitgraph（Git）图、C4图、思维导图、时间线、Zenuml、桑基图、XY图、区块图等。\t3. 使用Mermaid语法编写图表代码，确保语法正确。将图表代码放在 和 之间。\t4. 在图表之前和之后提供文本解释，解释图表内容和关键点。\t5. 如果问题复杂，使用多个图表来解释不同方面。\t6. 确保图表清晰简洁，避免过于复杂或信息过载。\t7. 在适当的情况下，将文本描述和图表结合起来，全面回答问题。\t8. 如果用户的问题是适合用常规方式回答，不用刻意使用图表。  \t    记住，使用图表的目的是使解释更直观易懂。使用图表时，始终旨在增强解释的清晰度和全面性。不要过度使用图表，你是一个头脑风暴大师不是图表大师。**Warning**：- 你不应该每次都把skills用完，而是根据问题分类选取最合适的方式回答- 其次你不应该偏离主题，以及你的**role**- 你应该在每段回复的末尾加上#theme 标签标识你在讨论的核心防止偏题if (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["Prompt"]},{"title":"标准","url":"/2026/02/05/%E6%A0%87%E5%87%86/","content":"标准\n很多事情都有标准……吗？就拿一个经典的作文题目来说吧：\n\n“在世界上，你认为什么东西是廉价的？什么东西是宝贵的？”\n\n这个作文题目好吗？好，非常好。为什么好？因为这就是在说标准这个东西，题目建立了一种假设每个都有一个标准，这个标准会把东西划分成宝贵和廉价，同时每个人的标准可能不同。\n这有两个问题：\n\n标准客观吗？\n廉价和宝贵重要吗？\n\n因为题目假设就是每个人都具有不同的标准这个标准自然是不标准的（坏笑），但是这是一道题目他是有参考答案的，既然带参考两个字那他一定有一定的推荐倾向，就说他认为我们的标准应当向某个标准靠近，这就违背了题目。这是否让你想到了什么？很多没有标准的东西，在冥冥之中已经被大众设置了标准。\n当然有很多东西与上面恰恰相反，下面我们来看第二个问题，廉价和宝贵重要吗？ 自然是不重要的，为什么？我们以班级成绩（假设都是同一张试卷）为例，80% 的人考了 90 分，但是我们以前 2% 来发奖状，我们把标准设置成 “得到奖状的人是优秀的、奋进的”，但是真的是这样吗？假设现在另一个班，98% 的人考了 99 分，2% 的逆天（bushi）考了 100 分，这  2%  也得到了奖状，那他们用 优秀 来代表对吗？当然不对了！99 的 和 90 的自然不是一个水平，但是他们的的标签 “宝贵” 、“廉价”、“优秀”、“平庸” 却是一样的，所以很多有标准的东西实际上并没有什么作用。\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["胡言乱语"],"tags":["Thinking"]},{"title":"关于学习","url":"/2025/11/09/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0/","content":"\n来自：Andy的观点\n\n高效学习的深层逻辑：在无用之用、知行合一与认知共生中成长\n近年来，“高效学习”成为热门话题，各类方法论层出不穷。然而，真正触及学习本质的路径，往往不在于技巧堆砌，而在于对学习本身的理解深度。有人提出一种看似“反效率”的高效学习观——强调疯狂阅读、创造作品、与善良高认知者交流。这一观点虽有其洞见，但也值得从哲学、科学、系统和实践四个层面深入剖析，并加以整合优化。\n\n一、哲学视角：在“无用之用”中重构学习的意义\n庄子曰：“人皆知有用之用，而莫知无用之用也。”主张大量读书而不问目的，正是对“无用之用”的当代诠释。当我们放下功利心，以对话古人的姿态沉浸于文本，实则是在体验人类精神世界的丰富性。那些书中人物经历的挣扎、困惑与顿悟，远比一句提炼出的名言更接近智慧的本质。\n然而，彻底否认目的性也可能走向虚无。海德格尔强调“此在”的筹划性——人生本就是带着关切（care）展开的存在。完全无目的的学习，容易陷入碎片化的信息漫游，缺乏整合力。真正的自由，不是拒绝目标，而是在广阔探索后，自主选择聚焦的方向。\n因此，高效学习的第一重境界是：以开放之心广泛涉猎，在“无目的”中积累认知土壤；再以自觉之意深耕某一领域，在“有方向”中结出思想果实。\n\n二、学科原理：认知科学验证“读—创—验”的闭环\n认知心理学研究表明，知识的内化需经历“输入—加工—输出—反馈”四个阶段。单纯阅读属于浅层编码，而创作（写作、编程、设计等）迫使大脑进行深度加工，触发“生成效应”（Generation Effect），显著提升记忆与理解。\n王阳明所说的“知行合一”，在现代神经科学中有其对应机制：行动会激活前额叶与运动皮层的协同，使抽象概念与具体情境绑定，形成可迁移的“情境化知识”。纸上谈兵之所以无效，正是因为缺少了这一神经重塑过程。\n同时，社会学习理论指出，高质量的社会互动是认知发展的催化剂。但关键不在对方是否“善良”，而在于交流是否具备认知异质性与心理安全性。一个善于提问、能激发反思的对话者，哪怕观点相左，也可能带来更大成长。\n因此，高效学习的第二重支撑是：构建“广读—深思—创作—反馈”的认知闭环，并在安全而多元的对话中迭代认知模型。\n\n三、系统流程：四维动态平衡的学习架构\n基于上述洞察，我们可以设计一个更具韧性的高效学习系统：\n\n\n广度与深度的动态平衡\n初期以“无目的”广泛阅读为主，建立跨学科心智模型；中期聚焦兴趣领域，进行主题式深度学习。\n\n\n输入与输出的螺旋上升\n每读十本书，至少产出一篇原创文章、一个项目或一次公开分享。输出不仅是检验，更是重构知识的方式。\n\n\n独立与协作的辩证统一\n保留独处沉思的时间，同时主动连接两类人：一是真诚分享的高认知者，二是敢于挑战你假设的“善意反对者”。\n\n\n情感与理性的协同运作\n允许自己在学习中感到迷茫、挫败甚至愤怒——这些情绪往往是认知边界的信号。记录它们，而非逃避。\n\n\n这个系统不追求线性效率，而强调螺旋式认知进化：每一次创作都是对阅读的回应，每一次对话都是对自我的超越。\n\n四、经验启示：在真实世界中检验认知\n最终，高效学习的价值不在于掌握多少知识，而在于能否在复杂现实中做出明智判断。当你遭遇利益冲突、道德困境或系统性压力时，书本上的道理才真正接受检验。\n此时，那些曾被你视为“无用”的思想历程、那些在创作中摔过的跟头、那些与善良者深夜长谈的顿悟，会悄然汇聚成你的判断力与行动力。\n但也需警惕：并非所有“高认知”都值得追随。有些人用知识包装操控，用逻辑掩饰自私。这时，善良不是认知的前提，而是筛选的标尺。果断远离消耗型关系，是保护认知生态的必要成本。\n\n结语：高效学习，是一场温柔而坚定的自我塑造\n真正的高效学习，不在速成，而在扎根；不在技巧，而在姿态。它要求我们既要有“读万卷书”的耐心，也要有“行万里路”的勇气；既要向世界开放，又要守住内心尺度。\n这不是一条轻松的路，但正如您所说——“那个过程远远不止一万小时”。因为真正的成长，从来不是时间的函数，而是深度参与的副产品。\n当我们在无用中见真知，在行动中验真理，在交流中生新知，学习便不再是手段，而成了存在本身的方式。\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }"},{"title":"比较有意思的话","url":"/2025/10/14/%E6%AF%94%E8%BE%83%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E8%AF%9D/","content":"\n\n人自己会变，而且他人不可能完全真实客观地说出对你的看法，所有特点都具有两面性。\n\n\n萨特说过：“他人即地狱。但实际上&quot;自身即地狱&quot;。\n\n\n每个故事都有许多条线索，人们总是避开那些与自己观点不吻合的线索。\n\n\n人类之所以会有突出的社交技巧（以及同样人类独有的社会问题），有一大原因也正出自于此。独自一人的母亲，如果还得拖着孩子，就很难为自己和小孩取得足够的食物。所以，想养孩子，就需要其他家族成员和邻居持续提供协助。要养活一个小孩，得靠全部落共同的努力。\n\n\n变化也常常伴随着失去。无所失则不得变，正因如此，人们常常说着要去改变，却依然驻足原地\n\n\n人生三大问题 职业社会爱\n\n\n兴百姓苦，亡百姓苦。\n\n\n爱人先爱己\n\n\n愉悦对方的同时也不要忘记愉悦自己，因为只有你同时也感到愉悦才能促使自己增加和对方的交流。如果一味讨好和奉承别人反而会受到别人的轻视，你自己也会感到无聊而疏远对方。\n\n\n看一个人的智力是否上乘，只看其脑子里能否同时容纳两种相反的思想而无碍于其处世行事。这个定理强调的是思想可以相反或者有某种混乱之处，但行为方式却一定要一致。\n\n\n某个专业的大学生毕业后能不能找到工作\n\n\n我们自己必须要做能工巧匠，必须对那些主张加以剪裁取舍，将它们整合成自己的决定，这样才能做个有主见的人。\n\n\n晕轮效应”(halo effect)，是指我们通常会先认识到一个人身上所具有的积极或消极方面的特征，然后就把这些特征和这个人的其他一切都联系起\n\n\n要抵制信念固着的倾向，只要我们记住，强势批判思维需要我们认识到所有的判断都是临时性的，或者与情境相关\n\n\n意义只能在交流中存在：只对某一个人有意义的话，实际上是没有意义的\n\n\n如果一个人不能直面真实的性，甚至对性抱有负面和羞耻的看法，ta就无法面对真实的自己。这样的人将很容易被他人掌控，因为ta崇尚外部力量，却害怕自身的欲望。所以不能掌控自己的命运。性即主体。\n\n\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["读书笔记"]},{"title":"补码","url":"/2025/08/10/%E8%A1%A5%E7%A0%81/","content":"作者：Liew.Y\nAIGC声明：部分使用AIGC\n\n\n对于正数，补码与原码相同的。\n\n\n负数在计算机中是使用其补码来表示的\n\n\n对于负数，补码是将原码的符号位保持不变，数值位按位取反后加1\n\n\n原码：10000001补码：Step1：11111110 Step2：11111111 \n在计算机中，反码（One's Complement） 是一种数值的二进制表示方法，常用于辅助补码的计算。它的规则相对简单，但存在一些局限性。以下是关于反码的详细说明：\n一、反码的定义与计算规则\n1. 正数的反码\n与原码相同，即 符号位为 0，数值位不变。\n示例：\n\n十进制数 +5（4 位）的原码和反码均为：0101。\n\n2. 负数的反码\n符号位为 1，数值位按位取反（0 变 1，1 变 0）。\n示例：\n\n十进制数 -5（4 位）的原码为 1101，反码为 1010（符号位不变，数值位 101 → 010）。\n\n二、反码的特点\n\n\n存在 “负零” 问题\n\n十进制 0 的反码有两种表示：\n\n+0 的反码：0000（4 位）。\n-0 的反码：1111（4 位）。\n\n\n这会导致逻辑判断混乱（例如 0000 和 1111 都表示 0），因此反码在实际计算机中很少直接使用，而是作为补码的中间步骤。\n\n\n\n取值范围\n\nn 位反码的取值范围为：\n-(2^&#123;n-1&#125;-1) ~ +(2^&#123;n-1&#125;-1)。\n示例（4 位）：\n\n最小值：1111（反码）→ 对应十进制 -7。\n最大值：0111（反码）→ 对应十进制 +7。\n\n\n\n\n\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["计算机基础"],"tags":["算法"]},{"title":"快速幂法","url":"/2025/08/09/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B3%95/","content":"作者：Liew.Y\n先上代码后面解释\n#include &lt;cstdio&gt;int main(void) &#123;    // 快速幂法int base = 2;  // 底数2int power = 14;  // 指数nint result = 1;  // 结果    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n什么是快速幂法？\n其本质就是把幂不断降次。\n如： 2(10)12=4(10)62^{12}_{(10)} = 4^{6}_{(10)}2​(10)​12​​=4​(10)​6​​\n这个时候我们需要思考一个问题\n\n幂运算的本质是什么？\n\n\n其本质就是连续的乘法\n\n这个时候我们又要思考一个问题\n如何把降幂运算和计算机结合？\n\\begin{aligned}\n&\\textbf{思维链}\\\\[4pt]\n1. &\\text{ 首先计算机运算以及数据储存的形式是\\textbf{二进制}}\\\\[4pt]\n2. &\\text{ 其次二进制每一位储存的形式是 }2^{n}\\\\[4pt]\n3. &\\text{ 而 } \\text{base} \\times \\text{base}= \\text{base}^{2}\\\\[4pt]\n4. &\\text{ 所以我们可以得到一个简单的思路}\\\\[4pt]\n5. &\\text{ 所有的 }n_{(10)}\\text{ 都可以使用二进制形式 }n_{(2)}\\text{ 来进行表示}\\\\[4pt]\n6. &\\text{ 对于 } \\text{base}^{\\text{power}} = \\text{base}^{2^{n}+2^{n-1}+\\dots+2^{0}}\\\\[4pt]\n7. &\\text{ 最终我们可以得到 } \\text{base}^{\\text{power}}=\\text{base}^{2^{n}}\\cdot \\text{base}^{2^{n-1}}\\cdot \\dots \\cdot \\text{base}^{2^{0}}\\\\[4pt]\n8. &\\text{ 我们还可以观察到 } \\text{base}^{2^{n}}=\\text{base}^{2^{n-1}}\\cdot \\text{base}^{2^{n-1}} = (\\text{base}^{2^{n-1}})^{2}\\\\[8pt]\n&\\boxed{\\text{结果：以 }\\text{base}^{2}\\text{ 为基础不断降幂}}\n\\end{aligned}\n\n此时我们自然的想到\nif 存在2的某次方对应的位数为0 &#123;\t不应该相乘&#125; else &#123;\t相乘&#125;进入下一位\n此时我们产生了一个问题：\n如何确定是否要相乘？\n\\begin{aligned}\n&\\textbf{思维链}\\\\[4pt]\n1. &\\text{ 计算机以二进制存储数据。}\\\\[4pt]\n2. &\\text{ 降幂本质：}\\quad \\text{base}^{2k}= (\\text{base}^{k})^{2} = \\text{base}^{k}\\cdot \\text{base}^{k} \\\\[4pt]\n3. &\\text{ 二进制位不连续，如 }1001_{(2)}\\\\[4pt]\n4. &\\text{ 仅需判断“当前位是否为 }1\\text{”} \\Rightarrow \\text{真假}\\\\[4pt]\n5. &\\text{ 不关心原值是否被破坏。}\\\\[6pt]\n6. &\\text{ 做法：}\\\\\n   &\\quad\\text{power} \\& 1  \\quad\\text{(取最低位)}\\\\\n   &\\quad\\text{power} \\gg 1 \\quad\\text{(右移一位，丢弃已处理位)}\\\\[6pt]\n&\\boxed{\\text{借助 }0000\\,0001_{(2)}\\text{ 逐位取值}}\n\\end{aligned}\n\n此时我们已经可以写出代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 3;int power = 5, result = 1;    while (power) &#123;        if (power &amp; 1) &#123;            result *= base;        &#125;        base *= base;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n进阶--递归法\nlong long fastPow(long long a, long long b) &#123;    if (b == 0) return 1;//截止条件    long long half = fastPow(a, b/2);//递归基    return (b % 2) ? half * half * a : half * half;//结果整合&#125;\n递归解析\n\n递归，递归，递归\n\nLiew.Y\n\n\n众所周知递归是很难理解的，所以针对递归我进行详细解释：其实是我不会\n\\begin{aligned}\n&\\textbf{Step1} \\quad\\text{从“分-治-合”的角度分析}\\\\[6pt]\n\\textbf{分} &: \\text{把指数 }b\\text{ 不断二分}\\\\\n&\\quad\\text{快速幂的降幂基础：} \\mathbf{base^{b}} = (\\mathbf{base^{b/2}})^{2}\\\\[4pt]\n\\textbf{治} &: \\text{计算子问题}\\\\\n&\\quad\\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[4pt]\n\\textbf{合} &: \\text{整合子结果}\\\\[4pt]\n\\text{若 b 为奇数}&: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2} \\cdot \\text{base}}\\\\[4pt]\n\\text{若 b 为偶数}&: \\mathbf{\\text{base}^{b} = \\text{base}^{b/2} \\cdot \\text{base}^{b/2}}\\\\[6pt]\n\\text{如何计算 }&\\mathbf{\\text{base}^{b/2^{n}}}\\\\[2pt]\n&\\text{利用 } \\mathbf{\\text{base}^{0}=1}\\\\[6pt]\n\\text{核心观察}&: \\mathbf{\\text{base}^{b} = \\bigl(\\text{base}^{b/2}\\bigr)^{2}}\n\\end{aligned}\n\n补充部分\n我们由此次观察不仅可以得到可以通过\n\nN&amp;1\n\n的形式取得低位\n同时也可以自然的得到另一种方法\nN%2\n\nPROVE\n如果N_{(2)}=1001_{(2)}\n则 N_{(10)}=2^{3}+2^{0} 的形式，其中前项是偶数 =&gt; 余数=2^{0}\n\n扩展\n模下快速幂\n\n必备知识\n(a \\times b) \\bmod c = ((a \\bmod c) \\times (b \\bmod c)) \\bmod c\n这里我们或许认为很难以记忆\n其实确实不好理解  但是我们直接简记：层层求模\n\n应用方法\n题目\n给定一个整数n求，2n2^{n}2​n​​对于1007的模;\n\n思维链\n\n首先要求幂运算，我们可以想到快速幂法\n其次要求模，刚好结合我们的扩展\n现在开始拆分\n首先 result = result * base\n我们当然第一时刻想到的是直接对最终结果求mod\n但是显而易见，计算机的数据储存很可能不足\n所以我们采用扩展的公式\n对result和base分别求mod\n思考结果：更改开头代码对二者分别求mod\n\n\n完整代码\n#include &lt;cstdio&gt;int main(void) &#123;int base = 2;int power, result = 1;    scanf(&quot;%d&quot;, &amp;power);    while (power) &#123;        if (power &amp; 1) &#123;            result = (result * base) % 1007;        &#125;        base = (base * base) % 1007;        power &gt;&gt;= 1;    &#125;    printf(&quot;%d&quot;, result);    return 0;&#125;\n注意\n虽然快速幂法相比于暴力算法更快\n但是需要记住快速幂法和暴力法一样都受制于内存的限制\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["ACM"],"tags":["算法"]},{"title":"读《隐藏的潜能》我得到了什么？","url":"/2025/08/14/%E8%AF%BB%E3%80%8A%E9%9A%90%E8%97%8F%E7%9A%84%E6%BD%9C%E8%83%BD%E3%80%8B%E6%88%91%E5%BE%97%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"作者：Liew.Y\n时间：2025-03-17\n海绵的故事\n在开始我们的故事之前，先认识一下主角——海绵（sponge）。它看似不起眼，却是地球上最古老的多细胞生物之一，化石可追溯到5.5亿年前的寒武纪。科学家在湖北宜昌发现的螺旋网格海绵化石，揭示了它作为原始动物的开端。古希腊人早就知道它，亚里士多德曾在书中记录它的用途，而希腊的KALYMNOS岛更以捕捞海绵闻名。300年前，那里的潜水员抱着15公斤的石头下潜30米，赤手抓取海绵；到19世纪，潜水服的发明让他们潜入70米深处，找到更优质的种类。\n但海绵的故事远不止这些。它曾被误认为是植物，因为它不移动、不捕食，静静地附着在海底。直到1765年，科学家通过研究它的细胞结构，才确认它属于动物。海绵没有华丽的外表，却能通过水流过滤食物，甚至在极端环境下存活亿万年。它的适应力令人惊叹——而这，正是我们今天要探讨的重点。\n潜能的冰山一角\n说到适应力，你有没有想过，那些被称作“天才”的人，成功的秘诀是什么？我们常把“天赋”（talent）当作答案。在英语里，“gift”既是天赋也是礼物，仿佛成功是上天赐予少数人的特权。可现实真是这样吗？\n中国有个神童叫“伤仲永”。一个天赋异禀的孩子，年少成名，却因缺乏后天培养，最终泯然众人。天赋固然重要，但没有坚持和方法，它不过是一块未雕的石头。而普通人呢？我们发挥的能力，往往只是自身潜能的冰山一角。\n海绵就是个活生生的例子。它没有腿脚，却能在海底扎根；没有猎食的本领，却能靠水流生存。这种“低调的强大”，不正是潜能的体现吗？天才的成功，靠的不仅是天赋，更是一种超乎常人的坚持——像海绵一样，面对恶劣环境不屈服。而我们普通人，之所以觉得自己“平凡”，或许只是因为还没挖掘出那隐藏的部分。\n持续：潜能的钥匙\n如果问大部分人为什么没能成功，答案往往是“我不够专注”。于是有人拼命练专注力，甚至科学研究也说“专注可以习得”。可结果呢？有些人苦练几年，成绩上去了，却过不了多久又回到原点，竹篮打水一场空。\n问题出在哪？不是不够努力，而是忽略了专注背后的东西——内驱力（internal drive）。王阳明说“心即理”，意思是真正的天理来自内心。海绵能在亿万年里存活，不是因为它“专注”过滤水流，而是因为它有种与生俱来的生存本能。天才也是如此：爱迪生试了上千种材料才发明灯泡，靠的不是天赋，是不服输的驱动力。\n现代社会太浮躁，纸醉金迷、唯利是图，让人容易迷失本心。我们羡慕天才，却忘了他们的成功不是天上掉下来的，而是从潜能里一点点挖出来的。接下来，我们会聊聊如何找到属于你的那股力量。\n抵抗力：进步的前提\n不论学习什么，这些东西都不是一蹴而就的，我们免不了失败，免不了笨手笨脚的阶段。就像我们学习骑自行车，我们终究是从一次次摔到后学会的而不是在逃避中得到的。从这件小事我们就可以知道，我们应该敢于面对失败。从阿里巴巴的马云到全球巨富马斯克，无不是在失败中进步，但可悲的是我们大部分人都缺失了这样的一种能力——抵抗力，所谓抵抗力简而言之就是面对挫折、他人言语的忍受程度。我们处在一个原子化的社会也是物质的社会，我们人与人的关系再也不像乡土文明那样紧密，“社恐”似乎成为了大部分人的标签，当你对一些“社恐重度患者”说要求他们尝试一些舞蹈、说唱。他们总会以“我社恐”为借口来推脱，这就是缺乏抵抗力的表现，羞于面对挫折。但这还是相对好的一类人，更严重的人是完全忽视挫折他们不愿从痛苦的回忆中学习，这使得这些人逐渐落后于时代，停滞不前。似乎抵抗力是一个很重要的东西，那如何增强呢？请跟随我一同探索.\n原则之法其一：抛弃完美主义\n完美主义的特征：总想全盘兼顾，眼里容不下瑕疵。完美主义的本质是想要创造心中的乌托邦，但现实是不完美的，再光滑的球也有凹槽，再平整的平面也有凸起，人无完人，完美主义者的特性比定使他们陷入&quot;完美黑洞”。哈佛研究显示，完美主义者拖延症发病率高40%这就是”完美黑洞的影响。\n原则之法其二：无赖心理\n说起无赖，大家总是一种厌恶的表情，毕竟谁也不想当无赖。但是无赖有一种心态特别适合我们学习，那就是无所谓心理，什么意思呢？就是对凡事都以一种“我与万物共舞&quot;的心态，这里当然不是让你轻视所有事件，而是让你选择性的对自己的错误报以这样的心态去面对，这样就可以以更为平和的心态去从错误中学习。\n最后我想说：适度的挫折依赖反而会使我们取得更大的进步。\n鹰架：激发内心的激荡\n这个部分我不想写了。\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["读书笔记"]},{"title":"资源整理_2","url":"/2025/08/10/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86-2/","content":"Author：Liew.Y\nDate: 2025-03-26 16:35\nGithub Profile: LiewYoung \n\n破山中贼易，破心中贼难。\n-王阳明\n\n前情提要\n本次更新主抓可用性、及时性、高效性致力于提升大学生生活质量，将学生从枯燥无味的重复且无意义的劳作中解放出来。使得我们真正实现学习价值。同时结合大部分学生对电脑的掌握情况，不足一些常用软件。\n\n日常多嘴\nOOP也就是面向对象是一种思想，请不要把它和编程语言绑定OK吧，下学期学JAVA可别就会用JAVA写个类的继承就说自己面向对象了。\n\n\n一个线程要么被分离（detach），让系统自动回收资源；要么被连接（join），由主线程手动等待并回收资源。两者必须选其一，否则可能导致资源泄漏或未定义行为。\n\n上期补全\n计算机教育课程系列\n计算机教育中缺失的一课 · the missing semester of your cs education\nAs we all know,高校本科阶段一般是教不了你什么真东西的。但是这些基础很重要：\n\n数据结构\n计算机组成原理\n操作系统\n计算机网络\n\n正文\n优质生活\n🎢工具学习类型的网站首页 - 廖雪峰的官方网站\nAs you can see! 一个类似编程扫盲的网站\n🧐OCS网课助手OCS网课助手\n你是否厌倦了枯燥且无聊的网课，面对100+的测试题你是否束手无策，没关系！现在你可以借助网课助手实现刷题刷课自由！！！Revolution！\n💻Optimizer卓越的Win11优化工具（这里F ** K Windows)Releases · hellzerg/optimizer\n🚀Nanazip快抛弃你那丑陋的WinRAR和像乌龟一样的自带解压缩吧Nanazip\n实际上我还是推荐有能力的去用7zip\n🙌Vmware免费好用的虚拟机软件，你用来干啥我不管，你不会下载请看VMware Workstation Pro 17官网下载安装教程_vmware17pro下载-CSDN博客\n\n再多嘴一次，你用Linux的话，为什么不用WSL呢？\n\nGithub选集\n入门日报521xueweihan/HelloGitHub: :octocat: 分享 GitHub 上有趣、入门级的开源项目。Share interesting, entry-level open source projects on GitHub.\n制作自己的编程语言Make your own\n\n我多嘴一句，如果你连Makefile都不会写，gcc是什么都不知道，动态库和静态库都不知道基本区别（不需要你知道太深）你还是好好练练吧。\n\nCoding-interview-universityjwasham/coding-interview-university: A complete computer science study plan to become a software engineer.\n卓越交流\nV2EX程序员的社区，纯净交流V2EX › 站点帮助首页请使用魔法访问\nAI小事记\n\n确实是没活了😶‍🌫️\n\n字节跳动旗下AI IDE（基于VScode）正式支持MCP功能。\nAI工具集合AI工具集官网 | 1000+ AI工具集合，国内外AI工具集导航大全\n看什么呢？学完了吗你！ 😂\n\nWin comes all day （赢麻了）\n\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["计算机基础"],"tags":["资源整理"]},{"title":"资源整理","url":"/2025/08/10/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/","content":"Author：Liew.Y\nDate: 2025-03-26 16:35（完成时间）\nGithub Profile: LiewYoung \n\n欢迎来到我的Github，目前只有一些简单的脚本项目。\n欢迎与我共同进步😶‍🌫️\n\n编程相关\n🤷‍♂️IO WIKI OI Wiki - OI Wiki\n介绍：\n一个ACM算法比赛爱好者的集合网站\n🚀菜鸟教程菜鸟教程 - 学的不仅是技术，更是梦想！\n介绍：\n一个编程学习网站\n万恶PPT\n🫡第一PPTPPT模板_PPT模版免费下载_免费PPT模板下载 -【第一PPT】\n介绍：\n这个网站或许不够出彩但一定好用\n👍优品PPTPPT人物素材_PPT人物插图_PPT人物图片 - 优品PPT\n介绍:\n经过我检验的PPT素材获取平台\n🐉字行天下字体天下-提供各类字体的免费下载和在线预览服务\n介绍：\n免费字体下载，装饰你的PPT\nAI工具\n\n这是我最喜欢的部分，哈哈。\n\n🚀KIMIKimi - 会推理解析，能深度思考的AI助手\n介绍：\n推荐的原因很简单，谁让他可以一键生成PPT呢\n💻TeraTrae - AI 原生 IDE\n介绍：\n基于AI构建的IDE，不过基础不牢可不要依赖\n🚀百度文心一言文心一言\n介绍：\n说到百度大家可能好感骤减，但不得不说自从文心一言完全免费之后百度是真香啊，毕竟国内唯一一个有代码执行器的AI\n社区类\n💻Linux DoLINUX DO - 新的理想型社区\n介绍：\n伟大理想主义者的联盟，在这里只有温和的技术交流没有抖音中的阴阳怪气\n工具类\n🎵音乐搜索音乐搜索器 - 多站合一音乐搜索,音乐在线试听\n介绍：\n作为一名资深本地音乐玩家，没有什么比找音乐资源更困难了\n🌍FreeMindFreeMind-Make your mind free\n介绍：\n开源免费的思维导图软件就是有点丑\n🔍ObsidianObsidian - Sharpen your thinking\n介绍：\n强大的双链接MarkDown笔记软件，唯一缺点就是云同步不过我就一台电脑要什么自行车\n➕GeGebraGeoGebra - the world’s favorite, free math tools used by over 100 million students and teachers\n介绍：\n免费强大、风靡全球的的数学工具\nif (typeof lightGallery !== 'undefined') {\n        var options = {\n            selector: '.gallery-item'\n        };\n        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);\n        }","categories":["计算机基础"],"tags":["资源整理"]}]